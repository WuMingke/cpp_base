函数的分文件编写
    创建后缀名为.h的头文件
    创建后缀名为.cpp的源文件
    在头文件中写函数的声明
    在源文件中写函数的定义

指针
    定义：就是一个内存地址
    作用：通过指针间接访问内存数据
    指针变量：保存指针地址的变量

    int a = 10; // 假设 10 存储在 0x0000
    0x0000 是一个指针地址
    int * p ; // 定义指针
    p = &a; // 取地址，等于0x0000
    那么  *p = 10； // 指针前加 * 代表解引用，找到指针指向的内存中的数据

    指针占的内存：在32位下占4字节，64位下占8字节

    空指针：指针变量指向内存中编号为0的空间
        作用：初始化指针变量
        注意：空指针指向的内存是不可以访问的

    野指针：

    const修饰指针的3种情况：
    const修饰指针：常量指针，指针指向的值不可以更改
    const修饰常量：指针常量，指针的指向不可以改，（指针的指向就是内存地址，不可以指向别的内存地址）
    const既修饰指针，又修饰常量：都不可以改

    普通变量作为函数参数时，是值传递，形参发生了变化，实参没有发生变化
    指针作为函数参数时，作的是地址传递，实参发生变化
    引用作函数参数时，简化指针，

结构体 struct
    通过结构体指针访问结构体中的属性，需要利用 “ -> ” 符号
    结构体指针作为函数参数的时候，避免了实参复制给形参的内存消耗，
    因为结构体占用的内存为4(8)字节，

内存模型
    C++程序在执行时，将内存分为4个区域
        代码区：存放函数体二进制代码，由操作系统进行管理。共享、只读
        全局区：存放全局变量和静态变量以及常量。程序结束时由操作系统回收
        栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
        堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
            new 关键字表示 =》开辟内存
            delete 关键字表示 =》释放内存

    int *func() {
        // p存放在栈区，new开辟的内存在栈区，new返回的是该数据类型的指针
        int *p = new int(10);
        return p;
    }

    int main() {
        int *p = func();
        cout << "result:" << *p << endl;
        delete p; // 释放内存空间

        // 释放数组：delete[] arr;  加一个中括号

        return 0;
    }

引用：给变量起别名
    数据类型 &别名 = 原名
    引用的本质：在C++内部的实现就是一个指针常量
        int &ref = a;
        编译器会转换为：int * const ref = &a; // 指针常量时指针的指向不可以更改，也说明为什么引用不可以更改

类 class
    访问权限 public private protected

    class和struct 的唯一区别在于 默认的访问权限不同
    class 默认权限为私有
    struct 默认权限为公共
    构造函数：程序在声明对象的时候会自动调用，而且只会调用一次
    析构函数：主要作用在于对象销毁前自动调用，执行一些清理工作
        ～类名(){}

    构造函数调用规则
    默认情况下，C++编译器至少给一个类添加3个函数
    默认构造函数
    默认析构函数
    默认拷贝构造函数 =》值传递的时候，会自动调用拷贝构造函数

    浅拷贝：简单的赋值拷贝操作
    深拷贝：在堆区重新申请空间，就行拷贝操作

    如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题，因为默认拷贝构造是浅拷贝

    当其它类对象作为本类成员，构造函数的调用是先调用其它类的构造，再调用本类的构造
    析构的调用顺序，是相反的，先调用本类的析构，再调用成员的析构

    静态成员：在成员变量或成员函数前加上关键字static
    静态成员变量：
        所有对象共享同一份数据
        在编译阶段分配内存
        类内声明，类外初始化
    静态成员函数：
        所有对象共享同一个函数
        静态成员函数只能访问静态成员变量

    成员变量和成员函数分开存储，只有非静态成员变量的内存占用 才属于类的对象上
    空对象占用内存空间为 1字节，为了区分空对象占内存的位置

    每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码
    那这一块代码是如何区分哪个对象调用自己的呢？
    this指针：指向被调用的成员函数所属的对象，它是隐含在每一个非静态成员函数内的一种指针，本质是指针常量
        用途：
        当形参和成员变量同名时，可用this指针来区分
        在类的非静态成员函数中返回对象本身，可使用 return *this

    const 修饰成员函数
    常函数：
        成员函数后面加const，这个函数就是常函数，本质是修饰this的指向，让指针指向的值不可以被修改
        常函数内不可以修改成员属性
        成员属性声明时加关键字mutable后，在常函数内就可以修改
    常对象：
        声明对象前加const，这个对象就是常对象
        常对象只能调用常函数

    友元：让一个函数或者类，访问另一个类中的私有成员
        关键字 friend
        实现
            全局函数做友元
            类做友元
            成员函数做友元

    继承：
        继承的方式，也有访问限制符修饰
        公共继承public
        保护继承protected
        私有继承private

        构造顺序
            先父类后子类
        析构顺序
            先子类后父类

        同名成员的处理：
        1 子类对象可以直接访问到子类中同名成员
        2 子类对象加作用域可以访问到父类同名成员
        3 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中的同名函数

        多继承，不建议






